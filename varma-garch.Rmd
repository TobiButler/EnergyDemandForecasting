---
title: "R Notebook"
output: html_notebook
---

This notebook is exploratory for the purposes of fitting a forecasting model

```{r}
# library(tidyverse)
library(tidytable)
library(rmgarch)
library(MTS)
library(forecast)
library(vars)
library(reticulate)
```

```{r}
print(getwd())
```

```{r}
training_data = read.csv(r"(Datasets/residuals.csv)", row.names = 1)
```

```{r}
colnames(training_data)
```

```{r}
head(training_data,5)
# training_data

# sapply(training_data, class)
```

```{r}
dummified_data <- training_data %>% get_dummies(drop_first = TRUE)
dummified_data = subset(dummified_data, select = !(names(dummified_data) %in% c("HourlyPrecipitation")))
```

```{r}
colnames(dummified_data)
```

Separate Energy Demand and Temperature. PCA the rest.

```{r}
not_pca_vars = c("Energy.Demand..MWH.", "HourlyDryBulbTemperature")
```

```{r}
not_pca_data <- dummified_data[, c("Energy.Demand..MWH.", "HourlyDryBulbTemperature")]
pca_data <- subset(dummified_data, select = !(names(dummified_data) %in% not_pca_vars))
scaled_data <- scale(pca_data)
# scaled_data
```

```{r}
pca_result <- prcomp(scaled_data)
```

```{r}
# # Principal components
# pca_result$rotation
# 
# # Standard deviations of principal components
# pca_result$sdev

# Proportion of variance explained by each principal component
prop_var <- (pca_result$sdev^2) / sum(pca_result$sdev^2)
prop_var
```

```{r}
# Scree plot
pca_keep <- prop_var > 1e-3
# pca_keep
orthogonal_data <- scaled_data %*% pca_result$rotation[,pca_keep]
dim(pca_result$rotation[,pca_keep])
dim(scaled_data)
  # as.data.frame(pca_result$rotation[,pca_keep])
# HOW TO CONVERT THIS INTO A DATAFRAME WITH COLUMNS...
dim(orthogonal_data)
# orthogonal_data
```

```{r}
endogenous_data <- cbind(not_pca_data, orthogonal_data)[,1:5]
endogenous_data
```

```{r}
var_model <- vars::VAR(endogenous_data, p=10, type="const")

```

```{r}
summary(var_model)
```

```{r}
predictions <- predict(var_model, n.ahead=1000)
predictions <- predictions$fcst$Energy.Demand..MWH.
```

```{r}
plot(predictions[,"fcst"])
```

Fit Prophet Models for squared errors based on residuals from VAR model

```{python}

```


Fit VAR Model for squared errors based on residuals from Prophet models above

Final model will need to be composed of all point forecasting Prophet models, point forecasting VAR model, single error forecasting Prophet model, and the error forecasting VAR model.

```{r}

```

```{r}
dim(endogenous_data)[2]
```

Now fit the GARCH model

```{r}
library(rmgarch)
library(parallel)
library(quantmod)

test <- endogenous_data[,1:2]
# dim(test)

xspec = ugarchspec(mean.model = list(armaOrder = c(1, 1)), variance.model = list(garchOrder = c(1,1), model = 'sGARCH'), distribution.model = 'norm')
uspec = multispec(replicate(dim(test)[2], xspec))
spec1 = dccspec(uspec = uspec, dccOrder = c(1, 1), distribution = 'mvnorm')
spec1a = dccspec(uspec = uspec, dccOrder = c(1, 1), model='aDCC', distribution = 'mvnorm')

```

```{r}

c <- cov(test)
det(c)
```

```{r}
cl = makePSOCKcluster(2)
multf = multifit(uspec, test, cluster = cl)

fit1 = dccfit(spec1, data = test, fit.control = list(eval.se = TRUE), fit = multf, cluster = cl)
# fit_adcc = dccfit(spec1, data = test, fit.control = list(eval.se = TRUE), fit = multf, cluster = cl)
print(fit1)           
# print(fit_adcc)

stopCluster(cl)
```

```{r}
garch_predictions <- dccforecast(fit=fit1, n.ahead = 1)
```

```{r}
plot(sigma(garch_predictions)[,1,1])
```

```{r}
predictions <- VARpred(var_model, h=10, output = FALSE)
```

```{r}
predictions
plot(predictions)
```

```{r}
times <- training_data %>% rownames()
print(times)
```

Fit multivariate GARCH model

```{r}
time_series_object <- ts(training_data, start = c(2022, 1), frequency = 24)  # Frequency for hourly data is 24
```
